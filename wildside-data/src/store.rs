use std::collections::HashMap;
use std::fs::File;
use std::io::BufReader;
use std::path::{Path, PathBuf};

use bincode::Options;
use geo::Rect;
use rusqlite::{Connection, OptionalExtension};
use thiserror::Error;
use wildside_core::{PoiStore, PointOfInterest, SpatialIndex};

/// SQLite-backed [`PoiStore`] that serves points of interest using a spatial index.
///
/// The store expects two artefacts generated by the offline ingestion pipeline:
/// a SQLite database containing serialised [`PointOfInterest`] rows and a
/// companion file holding a pre-built R\*-tree covering the same dataset. The
/// R\*-tree enables fast bounding-box queries whilst the database acts as the
/// canonical source of POI data.
///
/// # Examples
///
/// ```no_run
/// use geo::{Coord, Rect};
/// use rusqlite::Connection;
/// use std::fs::File;
/// use std::io::BufWriter;
/// use tempfile::TempDir;
/// use wildside_core::{PointOfInterest, Tags, build_spatial_index};
/// use wildside_data::SqlitePoiStore;
///
/// let dir = TempDir::new().expect("temp directory");
/// let db_path = dir.path().join("pois.db");
/// let index_path = dir.path().join("pois.rstar");
///
/// let poi = PointOfInterest::new(
///     1,
///     Coord { x: 0.0, y: 0.0 },
///     Tags::from([(String::from("name"), String::from("Example"))]),
/// );
/// let index = build_spatial_index(vec![poi.clone()]);
/// let file = File::create(&index_path).expect("index file");
/// let mut writer = BufWriter::new(file);
/// bincode::serialize_into(&mut writer, &index).expect("serialise index");
///
/// let conn = Connection::open(&db_path).expect("open sqlite");
/// conn.execute(
///     "CREATE TABLE pois (id INTEGER PRIMARY KEY, data BLOB NOT NULL)",
///     [],
/// )
/// .expect("create table");
/// let blob = bincode::serialize(&poi).expect("serialise poi");
/// conn.execute(
///     "INSERT INTO pois (id, data) VALUES (?1, ?2)",
///     (poi.id, blob),
/// )
/// .expect("insert poi");
///
/// let store = SqlitePoiStore::new(db_path, index_path).expect("create store");
/// let bbox = Rect::new(Coord { x: -1.0, y: -1.0 }, Coord { x: 1.0, y: 1.0 });
/// let pois: Vec<_> = store.get_pois_in_bbox(&bbox).collect();
/// assert_eq!(pois, vec![poi]);
/// ```
#[derive(Debug)]
pub struct SqlitePoiStore {
    index: SpatialIndex,
    pois: HashMap<u64, PointOfInterest>,
}

impl SqlitePoiStore {
    /// Load POIs from SQLite and their spatial index from disk.
    pub fn new(
        database_path: impl Into<PathBuf>,
        index_path: impl Into<PathBuf>,
    ) -> Result<Self, SqlitePoiStoreError> {
        let database_path = database_path.into();
        let index_path = index_path.into();
        let index = Self::load_index(&index_path)?;
        let pois = Self::load_pois(&database_path)?;
        Self::validate_index(&index, &pois)?;
        Ok(Self { index, pois })
    }

    fn load_index(path: &Path) -> Result<SpatialIndex, SqlitePoiStoreError> {
        let file = File::open(path).map_err(|source| SqlitePoiStoreError::OpenIndex {
            source,
            path: path.to_path_buf(),
        })?;
        let mut reader = BufReader::new(file);
        bincode::deserialize_from(&mut reader).map_err(|source| SqlitePoiStoreError::DecodeIndex {
            source,
            path: path.to_path_buf(),
        })
    }

    fn load_pois(path: &Path) -> Result<HashMap<u64, PointOfInterest>, SqlitePoiStoreError> {
        let connection =
            Connection::open(path).map_err(|source| SqlitePoiStoreError::OpenDatabase {
                source,
                path: path.to_path_buf(),
            })?;
        Self::ensure_schema(&connection, path)?;
        let mut statement = connection
            .prepare("SELECT id, data FROM pois")
            .map_err(|source| SqlitePoiStoreError::QueryPois {
                source,
                path: path.to_path_buf(),
            })?;
        let mut rows = statement
            .query([])
            .map_err(|source| SqlitePoiStoreError::QueryPois {
                source,
                path: path.to_path_buf(),
            })?;
        let mut pois = HashMap::new();
        let codec = bincode::DefaultOptions::new();
        while let Some(row) = rows
            .next()
            .map_err(|source| SqlitePoiStoreError::QueryPois {
                source,
                path: path.to_path_buf(),
            })?
        {
            let row_id: u64 = row
                .get("id")
                .map_err(|source| SqlitePoiStoreError::QueryPois {
                    source,
                    path: path.to_path_buf(),
                })?;
            let blob: Vec<u8> =
                row.get("data")
                    .map_err(|source| SqlitePoiStoreError::QueryPois {
                        source,
                        path: path.to_path_buf(),
                    })?;
            let poi: PointOfInterest =
                codec
                    .deserialize(&blob)
                    .map_err(|source| SqlitePoiStoreError::DecodePoi {
                        source,
                        id: row_id,
                        path: path.to_path_buf(),
                    })?;
            if poi.id != row_id {
                return Err(SqlitePoiStoreError::MismatchedPoiId {
                    row_id,
                    actual: poi.id,
                    path: path.to_path_buf(),
                });
            }
            pois.insert(row_id, poi);
        }
        Ok(pois)
    }

    fn ensure_schema(connection: &Connection, path: &Path) -> Result<(), SqlitePoiStoreError> {
        let mut statement = connection
            .prepare("SELECT 1 FROM sqlite_master WHERE type = 'table' AND name = 'pois' LIMIT 1")
            .map_err(|source| SqlitePoiStoreError::ReadSchema {
                source,
                path: path.to_path_buf(),
            })?;
        let exists = statement
            .query_row([], |row| row.get::<_, i32>(0))
            .optional()
            .map_err(|source| SqlitePoiStoreError::ReadSchema {
                source,
                path: path.to_path_buf(),
            })?;
        if exists.is_none() {
            return Err(SqlitePoiStoreError::MissingPoiTable {
                path: path.to_path_buf(),
            });
        }
        Ok(())
    }

    fn validate_index(
        index: &SpatialIndex,
        pois: &HashMap<u64, PointOfInterest>,
    ) -> Result<(), SqlitePoiStoreError> {
        let missing: Vec<u64> = index
            .iter()
            .map(|poi| poi.id)
            .filter(|id| !pois.contains_key(id))
            .collect();
        if missing.is_empty() {
            Ok(())
        } else {
            Err(SqlitePoiStoreError::MissingPois { missing })
        }
    }
}

impl PoiStore for SqlitePoiStore {
    fn get_pois_in_bbox(
        &self,
        bbox: &Rect<f64>,
    ) -> Box<dyn Iterator<Item = PointOfInterest> + Send + '_> {
        let min = bbox.min();
        let max = bbox.max();
        let matches = self.index.query_within(min, max);
        let pois: Vec<PointOfInterest> = matches
            .into_iter()
            .filter_map(|candidate| self.pois.get(&candidate.id))
            .cloned()
            .collect();
        Box::new(pois.into_iter())
    }
}

/// Errors raised when constructing a [`SqlitePoiStore`].
#[derive(Debug, Error)]
pub enum SqlitePoiStoreError {
    /// The SQLite database could not be opened.
    #[error("failed to open SQLite database at {path:?}")]
    OpenDatabase {
        /// Underlying SQLite error.
        source: rusqlite::Error,
        /// Path to the requested database file.
        path: PathBuf,
    },
    /// The R\*-tree index file could not be opened.
    #[error("failed to open spatial index file at {path:?}")]
    OpenIndex {
        /// Underlying I/O error.
        source: std::io::Error,
        /// Path to the index file.
        path: PathBuf,
    },
    /// Deserialising the index failed.
    #[error("failed to decode spatial index from {path:?}")]
    DecodeIndex {
        /// Deserialisation error.
        source: bincode::Error,
        /// Path to the index file.
        path: PathBuf,
    },
    /// The `pois` table is absent from the SQLite database.
    #[error("SQLite database at {path:?} is missing the 'pois' table")]
    MissingPoiTable {
        /// Path to the database file.
        path: PathBuf,
    },
    /// Inspecting the database schema failed.
    #[error("failed to inspect SQLite schema at {path:?}")]
    ReadSchema {
        /// Underlying SQLite error.
        source: rusqlite::Error,
        /// Path to the database file.
        path: PathBuf,
    },
    /// Querying POI rows failed.
    #[error("failed to read POI rows from SQLite database at {path:?}")]
    QueryPois {
        /// Underlying SQLite error.
        source: rusqlite::Error,
        /// Path to the database file.
        path: PathBuf,
    },
    /// A POI blob could not be decoded.
    #[error("failed to decode POI {id} from SQLite database at {path:?}")]
    DecodePoi {
        /// Deserialisation error.
        source: bincode::Error,
        /// Identifier of the POI that failed to decode.
        id: u64,
        /// Path to the database file.
        path: PathBuf,
    },
    /// The POI identifier stored in SQLite disagrees with the blob content.
    #[error(
        "POI row {row_id} deserialised with mismatched identifier {actual} in SQLite database at {path:?}"
    )]
    MismatchedPoiId {
        /// Identifier declared by the row.
        row_id: u64,
        /// Identifier encoded within the blob.
        actual: u64,
        /// Path to the database file.
        path: PathBuf,
    },
    /// The spatial index references POIs absent from the database.
    #[error("spatial index references missing POIs: {missing:?}")]
    MissingPois {
        /// Missing identifiers.
        missing: Vec<u64>,
    },
}

#[cfg(test)]
mod tests;
